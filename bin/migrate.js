#!/usr/bin/env node

// Êï∞ÊçÆÂ∫ìËøÅÁßªÂëΩ‰ª§Ë°åÂ∑•ÂÖ∑
const { Command } = require('commander');
const { initializeConfig } = require('../src/config/environment');
const DatabaseMigrator = require('../src/database/migrator');
const DatabaseSeeder = require('../src/database/seeder');
const { Sequelize } = require('sequelize');

const program = new Command();

// ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìËøûÊé•
let sequelize;

async function initDatabase() {
  try {
    const config = initializeConfig();
    
    if (config.isDevelopment || config.isTest) {
      sequelize = new Sequelize({
        dialect: 'sqlite',
        storage: config.database.storage || './database/tutorial.db',
        logging: config.isDevelopment ? console.log : false
      });
    } else {
      // Áîü‰∫ßÁéØÂ¢ÉÊï∞ÊçÆÂ∫ìÈÖçÁΩÆ
      sequelize = new Sequelize(process.env.DATABASE_URL, {
        dialect: 'postgres', // ÊàñÂÖ∂‰ªñÊï∞ÊçÆÂ∫ì
        logging: false
      });
    }
    
    await sequelize.authenticate();
    console.log('‚úÖ Database connection established successfully.');
    return sequelize;
    
  } catch (error) {
    console.error('‚ùå Unable to connect to the database:', error.message);
    process.exit(1);
  }
}

// ÂÖ≥Èó≠Êï∞ÊçÆÂ∫ìËøûÊé•
async function closeDatabase() {
  if (sequelize) {
    await sequelize.close();
  }
}

// ËøÅÁßªÂëΩ‰ª§
program
  .command('migrate:up')
  .description('Run pending migrations')
  .action(async () => {
    try {
      const db = await initDatabase();
      const migrator = new DatabaseMigrator(db);
      
      console.log('üöÄ Running migrations...');
      const result = await migrator.migrateUp();
      
      if (result.total === 0) {
        console.log('üìã No pending migrations found.');
      } else {
        console.log(`‚úÖ Successfully executed ${result.total} migrations:`);
        result.executed.forEach(migration => {
          console.log(`  - ${migration}`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Migration failed:', error.message);
      process.exit(1);
    } finally {
      await closeDatabase();
    }
  });

program
  .command('migrate:down')
  .description('Rollback migrations')
  .option('-s, --steps <number>', 'Number of migrations to rollback', '1')
  .action(async (options) => {
    try {
      const db = await initDatabase();
      const migrator = new DatabaseMigrator(db);
      const steps = parseInt(options.steps);
      
      console.log(`üîÑ Rolling back ${steps} migration(s)...`);
      const result = await migrator.migrateDown(steps);
      
      if (result.total === 0) {
        console.log('üìã No migrations to rollback.');
      } else {
        console.log(`‚úÖ Successfully rolled back ${result.total} migrations:`);
        result.rolledBack.forEach(migration => {
          console.log(`  - ${migration}`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Migration rollback failed:', error.message);
      process.exit(1);
    } finally {
      await closeDatabase();
    }
  });

program
  .command('migrate:status')
  .description('Show migration status')
  .action(async () => {
    try {
      const db = await initDatabase();
      const migrator = new DatabaseMigrator(db);
      
      const status = await migrator.getStatus();
      
      console.log('üìä Migration Status:');
      console.log(`  Total: ${status.total}`);
      console.log(`  Executed: ${status.executed}`);
      console.log(`  Pending: ${status.pending}`);
      console.log('');
      
      if (status.migrations.length > 0) {
        console.log('Migration files:');
        status.migrations.forEach(migration => {
          const icon = migration.executed ? '‚úÖ' : '‚è≥';
          const state = migration.executed ? 'executed' : 'pending';
          console.log(`  ${icon} ${migration.name} (${state})`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Failed to get migration status:', error.message);
      process.exit(1);
    } finally {
      await closeDatabase();
    }
  });

program
  .command('migrate:reset')
  .description('Reset all migrations (DANGEROUS)')
  .option('--force', 'Force reset without confirmation')
  .action(async (options) => {
    try {
      if (!options.force) {
        console.log('‚ö†Ô∏è  WARNING: This will drop all tables and data!');
        console.log('Use --force flag to confirm this action.');
        process.exit(1);
      }
      
      const db = await initDatabase();
      const migrator = new DatabaseMigrator(db);
      
      console.log('üîÑ Resetting all migrations...');
      const result = await migrator.reset();
      
      console.log(`‚úÖ Successfully reset ${result.count} migrations.`);
      
    } catch (error) {
      console.error('‚ùå Migration reset failed:', error.message);
      process.exit(1);
    } finally {
      await closeDatabase();
    }
  });

// ÁßçÂ≠êÊï∞ÊçÆÂëΩ‰ª§
program
  .command('seed:up')
  .description('Run pending seeders')
  .action(async () => {
    try {
      const db = await initDatabase();
      const seeder = new DatabaseSeeder(db);
      
      console.log('üå± Running seeders...');
      const result = await seeder.seedUp();
      
      if (result.total === 0) {
        console.log('üìã No pending seeders found.');
      } else {
        console.log(`‚úÖ Successfully executed ${result.total} seeders:`);
        result.executed.forEach(seederFile => {
          console.log(`  - ${seederFile}`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Seeding failed:', error.message);
      process.exit(1);
    } finally {
      await closeDatabase();
    }
  });

program
  .command('seed:down')
  .description('Rollback seeders')
  .option('-s, --steps <number>', 'Number of seeders to rollback', '1')
  .action(async (options) => {
    try {
      const db = await initDatabase();
      const seeder = new DatabaseSeeder(db);
      const steps = parseInt(options.steps);
      
      console.log(`üîÑ Rolling back ${steps} seeder(s)...`);
      const result = await seeder.seedDown(steps);
      
      if (result.total === 0) {
        console.log('üìã No seeders to rollback.');
      } else {
        console.log(`‚úÖ Successfully rolled back ${result.total} seeders:`);
        result.rolledBack.forEach(seederFile => {
          console.log(`  - ${seederFile}`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Seeder rollback failed:', error.message);
      process.exit(1);
    } finally {
      await closeDatabase();
    }
  });

program
  .command('seed:status')
  .description('Show seeder status')
  .action(async () => {
    try {
      const db = await initDatabase();
      const seeder = new DatabaseSeeder(db);
      
      const status = await seeder.getStatus();
      
      console.log('üìä Seeder Status:');
      console.log(`  Total: ${status.total}`);
      console.log(`  Executed: ${status.executed}`);
      console.log(`  Pending: ${status.pending}`);
      console.log('');
      
      if (status.seeders.length > 0) {
        console.log('Seeder files:');
        status.seeders.forEach(seederFile => {
          const icon = seederFile.executed ? '‚úÖ' : '‚è≥';
          const state = seederFile.executed ? 'executed' : 'pending';
          console.log(`  ${icon} ${seederFile.name} (${state})`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Failed to get seeder status:', error.message);
      process.exit(1);
    } finally {
      await closeDatabase();
    }
  });

program
  .command('seed:refresh')
  .description('Reset and re-run all seeders')
  .option('--force', 'Force refresh without confirmation')
  .action(async (options) => {
    try {
      if (!options.force) {
        console.log('‚ö†Ô∏è  WARNING: This will remove all seeded data and re-seed!');
        console.log('Use --force flag to confirm this action.');
        process.exit(1);
      }
      
      const db = await initDatabase();
      const seeder = new DatabaseSeeder(db);
      
      console.log('üîÑ Refreshing all seeders...');
      const result = await seeder.refresh();
      
      console.log(`‚úÖ Successfully refreshed ${result.total} seeders.`);
      
    } catch (error) {
      console.error('‚ùå Seeder refresh failed:', error.message);
      process.exit(1);
    } finally {
      await closeDatabase();
    }
  });

// ÁªÑÂêàÂëΩ‰ª§
program
  .command('db:setup')
  .description('Setup database (run migrations and seeders)')
  .action(async () => {
    try {
      const db = await initDatabase();
      const migrator = new DatabaseMigrator(db);
      const seeder = new DatabaseSeeder(db);
      
      console.log('üèóÔ∏è  Setting up database...');
      
      // ËøêË°åËøÅÁßª
      console.log('üìä Running migrations...');
      const migrationResult = await migrator.migrateUp();
      if (migrationResult.total > 0) {
        console.log(`‚úÖ Executed ${migrationResult.total} migrations.`);
      }
      
      // ËøêË°åÁßçÂ≠êÊï∞ÊçÆ
      console.log('üå± Running seeders...');
      const seederResult = await seeder.seedUp();
      if (seederResult.total > 0) {
        console.log(`‚úÖ Executed ${seederResult.total} seeders.`);
      }
      
      console.log('üéâ Database setup completed successfully!');
      
    } catch (error) {
      console.error('‚ùå Database setup failed:', error.message);
      process.exit(1);
    } finally {
      await closeDatabase();
    }
  });

program
  .command('db:reset')
  .description('Reset database (drop all and re-setup)')
  .option('--force', 'Force reset without confirmation')
  .action(async (options) => {
    try {
      if (!options.force) {
        console.log('‚ö†Ô∏è  WARNING: This will completely reset the database!');
        console.log('Use --force flag to confirm this action.');
        process.exit(1);
      }
      
      const db = await initDatabase();
      const migrator = new DatabaseMigrator(db);
      const seeder = new DatabaseSeeder(db);
      
      console.log('üîÑ Resetting database...');
      
      // ÈáçÁΩÆÁßçÂ≠êÊï∞ÊçÆ
      try {
        await seeder.reset();
        console.log('‚úÖ Seeders reset.');
      } catch (error) {
        console.log('‚ÑπÔ∏è  No seeders to reset.');
      }
      
      // ÈáçÁΩÆËøÅÁßª
      await migrator.reset();
      console.log('‚úÖ Migrations reset.');
      
      // ÈáçÊñ∞ËÆæÁΩÆÊï∞ÊçÆÂ∫ì
      console.log('üèóÔ∏è  Re-setting up database...');
      await migrator.migrateUp();
      await seeder.seedUp();
      
      console.log('üéâ Database reset completed successfully!');
      
    } catch (error) {
      console.error('‚ùå Database reset failed:', error.message);
      process.exit(1);
    } finally {
      await closeDatabase();
    }
  });

// Â§ÑÁêÜÁ®ãÂ∫èÈÄÄÂá∫
process.on('SIGINT', async () => {
  console.log('\nüõë Received SIGINT, closing database connection...');
  await closeDatabase();
  process.exit(0);
});

program.parse(process.argv);

// Â¶ÇÊûúÊ≤°ÊúâÊèê‰æõÂëΩ‰ª§ÔºåÊòæÁ§∫Â∏ÆÂä©
if (!process.argv.slice(2).length) {
  program.outputHelp();
}